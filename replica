#!/bin/bash

TARGET=
SOURCEROOT=
DESTROOT=
LOGFILE=
VERBOSE=
RETRIES="0"
WAIT="3600"
EXTRAOPTIONS="--quiet"
STARTTIME=`date +%s`

function printhelp() {
cat << EOF
replica 0.1 by AndrÃ© Restivo (andre.restivo@gmail.com) https://github.com/arestivo/replica

Usage: replica -d <destroot> [-s <sourceroot>] -t <target> [-b <logfile>] [-r <retries>] [-w <wait] [-v] [-h]

	-d 	Directory where backups and log files will be created (unless -b is used).
	-s	Directory where source target can be found. Can be a remote location 
		using ssh. If source is a remote location we cannot verify if contents 
		have changed before executing the rsync command and a new directory will 
		always be created. Default: current directory.
	-t	Source target.
	-b 	Alternative log file.
	-r 	How many times to retry a remote rsync. Default: 0
	-w 	How many seconds to wait between retries. Default: 3600
	-b 	Alternative log file.
	-v	Detailed output for testing
	-h	This help message.

Example: replica -d backups -s /home/johndoe/Documents/ -t work -v

	Creates an incremental backup of /home/johndoe/Documents/work in 
	./backups/work and stores the backup log in ./backups/.replica.log

Example: replica -d backups -s johndoe@work:~/Documents/ -t stuff -v -b backup.log

	Creates an incremental backup of /home/johndoe/Documents/stuff
	found at server work in ./backups/stuff and stores the backup log 
	in backup.log

EOF
}

while getopts "s:d:t:b:r:w:vh" option; do
	case "$option" in
		s) SOURCEROOT="$OPTARG";;
		d) DESTROOT="$OPTARG";;
		t) TARGET="$OPTARG";;
		b) LOGFILE="$OPTARG";;
		r) RETRIES="$OPTARG";;
		w) WAIT="$OPTARG";;
		v) VERBOSE="0";;
		h) printhelp; exit 0;;
		\?) echo "Usage: replica -d <destroot> [-s <sourceroot>] -t <target> [-b <logfile>] [-r <retries>] [-w <wait] [-v] [-h]"; exit 1;;
	esac
done

if [ "$TARGET" == "" ]; then echo "Error: No target specified. Use -h if you need help."; exit 1; fi
if [ "$DESTROOT" == "" ]; then echo "Error: No destination root specified. Use -h if you need help."; exit 1; fi
if [ "$SOURCEROOT" == "" ]; then SOURCEROOT=`pwd`/; fi

if [[ $SOURCEROOT != *@* ]]; then
	if [ ! -d "$SOURCEROOT" ]; then echo "Error: $SOURCEROOT is not a directory. Use -h if you need help."; exit 1; fi
fi
if [[ $DESTROOT == *@* ]]; then echo "Error: $DESTROOT is not a local path. Use -h if you need help."; exit 1; fi
if [ ! -d "$DESTROOT" ]; then mkdir -p $DESTROOT; fi
if [ ! -d "$DESTROOT" ]; then echo "Error: $DESTROOT is not a directory. Use -h if you need help."; exit 1; fi

#SOURCEROOT=`cd $SOURCEROOT; pwd`
DESTROOT=`cd $DESTROOT; pwd`

SOURCE=$SOURCEROOT/$TARGET/
DEST=$DESTROOT/$TARGET/

if [ "$VERBOSE" == "0" ]; then
	echo "$SOURCE -> $DEST"
	EXTRAOPTIONS="--verbose --progress"
fi

if [ "$LOGFILE" == "" ]; then
	LOGFILE=$DESTROOT/.replica.log
fi

#exit 0

if [ ! -d $DEST ]; then mkdir -p $DEST; fi

# Get current date
DATE=`date +%Y%m%d.%H%M%S`

# Get date of last backup
PREVIOUS=`find $DEST -maxdepth 1 -printf "%P\n" | grep "[0-9]\{8\}.[0-9]\{6\}" | sort | tail -1`

SHAOLD=`find $DEST$PREVIOUS -printf "%P %s \n" | sort | sha1sum`

if [[ $SOURCE != *@* ]]; then
	SHANEW=`find $SOURCE -printf "%P %s \n" | sort | sha1sum`
fi

if [ "$SHANEW" == "$SHAOLD" ]; then
	ENDTIME=`date +%s` ; TIMEELAPSED=$((ENDTIME - STARTTIME))
	SIZE=`du --si --summarize $DEST$PREVIOUS | awk '{print $1}'`
	echo "[$TARGET] $DATE ($SIZE): Nothing to be done ($TIMEELAPSED s)" >> $LOGFILE
	if [ "$VERBOSE" == "0" ]; then echo "Nothing to be done"; fi
	exit 0
fi

if [ "$VERBOSE" == "0" ]; then
	echo "rsync $EXTRAOPTIONS --inplace --archive --delete --link-dest $DEST$PREVIOUS/ $SOURCE $DEST$DATE.incomplete/"
fi

until [ $RETRIES == "-1" ]; do

	rsync $EXTRAOPTIONS --inplace --archive --delete --link-dest $DEST$PREVIOUS $SOURCE $DEST$DATE.incomplete/

	if [ $? -eq 0 ]; then 
		ENDTIME=`date +%s` ; TIMEELAPSED=$((ENDTIME - STARTTIME))
		mv $DEST$DATE.incomplete $DEST$DATE
		SIZE=`du --si --summarize $DEST$DATE | awk '{print $1}'`
		if [ "$PREVIOUS" != "" ]; then 
			echo "[$TARGET] $DATE ($SIZE): Incremental backup from $PREVIOUS complete ($TIMEELAPSED s)" >> $LOGFILE
		else
			echo "[$TARGET] $DATE ($SIZE): Full backup complete ($TIMEELAPSED s)" >> $LOGFILE
		fi
		break
	else
		ENDTIME=`date +%s` ; TIMEELAPSED=$((ENDTIME - STARTTIME))
		if [ -d $DEST$DATE.incomplete ]; then
			SIZE=`du --si --summarize $DEST$DATE.incomplete | awk '{print $1}'`
		else
			SIZE="0B"
		fi
		if [ $RETRIES == "0" ]; then echo "[$TARGET] $DATE ($SIZE): Failed backup ($TIMEELAPSED s) Giving up" >> $LOGFILE;
		else echo "[$TARGET] $DATE ($SIZE): Failed backup ($TIMEELAPSED s) Retrying in $WAIT s" >> $LOGFILE; fi
	fi

	if [[ $SOURCE != *@* ]]; then
		break
	fi

	if [ $RETRIES != "0" ]; then 
		sleep $WAIT
		STARTTIME=`date +%s`
	fi
	RETRIES=$(($RETRIES - 1))
done